---
# tasks file for kubernetes-master

# Certificate Preparation for Kubernetes Masters (running from bastion host)
- name: Create local files directory on bastion host
  file:
    path: "{{ playbook_dir }}/files"
    state: directory
    mode: '0755'
  delegate_to: localhost
  run_once: true
  when: inventory_hostname == groups['masters'][0]
  become: false

- name: Copy ETCD CA certificate to temp location on ETCD node
  copy:
    src: /etc/ssl/etcd/ca.crt
    dest: /tmp/etcd-ca.crt
    remote_src: yes
    mode: '0644'
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fetch ETCD CA certificate from ETCD node to bastion
  fetch:
    src: /tmp/etcd-ca.crt
    dest: "{{ playbook_dir }}/files/etcd-ca.crt"
    flat: yes
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Copy ETCD server certificate to temp location on ETCD node
  copy:
    src: /etc/ssl/etcd/server.crt
    dest: /tmp/server.crt
    remote_src: yes
    mode: '0644'
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fetch ETCD server certificate from ETCD node to bastion
  fetch:
    src: /tmp/server.crt
    dest: "{{ playbook_dir }}/files/server.crt"
    flat: yes
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Copy ETCD server key to temp location on ETCD node
  copy:
    src: /etc/ssl/etcd/server.key
    dest: /tmp/server.key
    remote_src: yes
    mode: '0600'
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fetch ETCD server private key from ETCD node to bastion
  fetch:
    src: /tmp/server.key
    dest: "{{ playbook_dir }}/files/server.key"
    flat: yes
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Generate Kubernetes master client certificate on first ETCD node
  shell: |
    cd /tmp
    openssl genrsa -out k3s-client.key 2048
    openssl req -new -key k3s-client.key -out k3s-client.csr -subj "/CN=k3s-client"
    openssl x509 -req -in k3s-client.csr -CA /etc/ssl/etcd/ca.crt -CAkey /etc/ssl/etcd/ca.key -CAcreateserial -out k3s-client.crt -days 365
    chmod 644 k3s-client.crt
    chmod 600 k3s-client.key
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fetch Kubernetes client certificate from ETCD node
  fetch:
    src: /tmp/k3s-client.crt
    dest: "{{ playbook_dir }}/files/k3s-client.crt"
    flat: yes
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fetch Kubernetes client private key from ETCD node
  fetch:
    src: /tmp/k3s-client.key
    dest: "{{ playbook_dir }}/files/k3s-client.key"
    flat: yes
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Set proper permissions for fetched certificates on bastion host
  file:
    path: "{{ item.path }}"
    mode: "{{ item.mode }}"
  loop:
    - { path: "{{ playbook_dir }}/files/etcd-ca.crt", mode: "644" }
    - { path: "{{ playbook_dir }}/files/server.crt", mode: "644" }
    - { path: "{{ playbook_dir }}/files/server.key", mode: "600" }
    - { path: "{{ playbook_dir }}/files/k3s-client.crt", mode: "644" }
    - { path: "{{ playbook_dir }}/files/k3s-client.key", mode: "600" }
  delegate_to: localhost
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Verify certificate files exist on bastion host
  stat:
    path: "{{ item }}"
  loop:
    - "{{ playbook_dir }}/files/etcd-ca.crt"
    - "{{ playbook_dir }}/files/server.crt"
    - "{{ playbook_dir }}/files/server.key"
    - "{{ playbook_dir }}/files/k3s-client.crt"
    - "{{ playbook_dir }}/files/k3s-client.key"
  register: cert_files_stat
  delegate_to: localhost
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Fail if any certificate files are missing
  fail:
    msg: "Certificate file {{ item.item }} is missing on bastion host!"
  loop: "{{ cert_files_stat.results }}"
  when: 
    - inventory_hostname == groups['masters'][0]
    - not item.stat.exists

- name: Display certificate preparation status
  debug:
    msg: "Certificates successfully prepared on bastion host for master deployment"
  when: inventory_hostname == groups['masters'][0]

- name: Clean up temporary files on ETCD node
  file:
    path: "{{ item }}"
    state: absent
  loop:
    - /tmp/etcd-ca.crt
    - /tmp/server.crt
    - /tmp/server.key
    - /tmp/k3s-client.crt
    - /tmp/k3s-client.key
    - /tmp/k3s-client.csr
  delegate_to: "{{ groups['etcd'][0] }}"
  run_once: true
  when: inventory_hostname == groups['masters'][0]

- name: Install prerequisites for Kubernetes
  yum:
    name:
      - wget
      - tar
    state: present

- name: Disable swap
  shell: |
    sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
    swapoff -a
  when: ansible_swaptotal_mb > 0

- name: Configure kernel modules for Kubernetes
  shell: |
    modprobe overlay
    modprobe br_netfilter
    
- name: Configure sysctl for Kubernetes networking
  copy:
    dest: /etc/sysctl.d/kubernetes.conf
    content: |
      net.bridge.bridge-nf-call-ip6tables = 1
      net.bridge.bridge-nf-call-iptables = 1
      net.ipv4.ip_forward = 1
  notify: reload sysctl

- name: Create PKI directory for certificates
  file:
    path: /etc/pki/k3s
    state: directory
    mode: '0755'

- name: Copy ETCD CA certificate
  copy:
    src: "{{ playbook_dir }}/files/etcd-ca.crt"
    dest: /etc/pki/k3s/etcd-ca.crt
    mode: '0644'

- name: Copy Kubernetes client certificate
  copy:
    src: "{{ playbook_dir }}/files/k3s-client.crt"
    dest: /etc/pki/k3s/client.crt
    mode: '0644'

- name: Copy Kubernetes client private key
  copy:
    src: "{{ playbook_dir }}/files/k3s-client.key"
    dest: /etc/pki/k3s/client.key
    mode: '0600'

- name: Check if K3S is already installed
  stat:
    path: /usr/local/bin/k3s
  register: k3s_binary

- name: Install K3S on first master node
  shell: |
    curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE="644" sh -s - server \
      --token="{{ k3s_token }}" \
      --datastore-endpoint="https://{{ etcd_endpoint }}:2379" \
      --datastore-cafile="/etc/pki/k3s/etcd-ca.crt" \
      --datastore-certfile="/etc/pki/k3s/client.crt" \
      --datastore-keyfile="/etc/pki/k3s/client.key" \
      --tls-san="{{ haproxy_hostname }}" \
      --tls-san="{{ haproxy_ip }}" \
      --cluster-init
  when: 
    - not k3s_binary.stat.exists
    - inventory_hostname == groups['masters'][0]
  notify: restart k3s

- name: Install K3S on additional master nodes
  shell: |
    curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE="644" sh -s - server \
      --token="{{ k3s_token }}" \
      --server="https://{{ haproxy_ip }}:6443" \
      --datastore-endpoint="https://{{ etcd_endpoint }}:2379" \
      --datastore-cafile="/etc/pki/k3s/etcd-ca.crt" \
      --datastore-certfile="/etc/pki/k3s/client.crt" \
      --datastore-keyfile="/etc/pki/k3s/client.key" \
      --tls-san="{{ haproxy_hostname }}" \
      --tls-san="{{ haproxy_ip }}"
  when: 
    - not k3s_binary.stat.exists
    - inventory_hostname != groups['masters'][0]
  notify: restart k3s

- name: Check K3S service status after installation
  shell: systemctl status k3s.service
  register: k3s_status
  failed_when: false

- name: Get K3S service logs if failed
  shell: journalctl -xeu k3s.service --no-pager -l
  register: k3s_logs
  when: k3s_status.rc != 0

- name: Display K3S service status
  debug:
    msg: "{{ k3s_status.stdout_lines + k3s_status.stderr_lines }}"
  when: k3s_status.rc != 0

- name: Display K3S service logs
  debug:
    msg: "{{ k3s_logs.stdout_lines }}"
  when: 
    - k3s_status.rc != 0
    - k3s_logs is defined

- name: Test ETCD connectivity from master node
  shell: |
    curl -k --cert /etc/pki/k3s/client.crt --key /etc/pki/k3s/client.key \
    --cacert /etc/pki/k3s/etcd-ca.crt https://{{ etcd_endpoint }}:2379/health
  register: etcd_test
  failed_when: false

- name: Display ETCD connectivity test
  debug:
    msg: "ETCD connectivity test: {{ etcd_test.stdout if etcd_test.rc == 0 else etcd_test.stderr }}"

- name: Force restart K3S service if it failed to start
  systemd:
    name: k3s
    state: restarted
    daemon_reload: yes
  when: k3s_status.rc != 0

- name: Wait for K3S service to be running
  systemd:
    name: k3s
    state: started
    enabled: yes
  retries: 5
  delay: 10
  register: k3s_service_result
  until: k3s_service_result is succeeded

- name: Verify K3S installation
  shell: k3s kubectl get nodes
  register: k3s_nodes
  retries: 3
  delay: 10
  until: k3s_nodes.rc == 0

- name: Display cluster nodes
  debug:
    msg: "{{ k3s_nodes.stdout_lines }}"
  when: k3s_nodes is succeeded

- name: Create kubectl alias for ec2-user
  lineinfile:
    path: /home/ec2-user/.bashrc
    line: "alias kubectl='k3s kubectl'"
    create: yes
    
- name: Set up kubeconfig for ec2-user
  shell: |
    mkdir -p /home/ec2-user/.kube
    cp /etc/rancher/k3s/k3s.yaml /home/ec2-user/.kube/config
    chown ec2-user:ec2-user /home/ec2-user/.kube/config
    chmod 600 /home/ec2-user/.kube/config
  when: inventory_hostname == groups['masters'][0]